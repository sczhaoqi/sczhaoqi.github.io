<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Java:Annotation(注解)--原理到案例 | Hexo</title><meta name="description" content="Java:Annotation(注解)--原理到案例 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/css/font-awesome.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hexo"><img class="logo-image" src="/favicon.ico" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/" target="_self">首页</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/archives" target="_self">归档</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/tags" target="_self">标签</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/about" target="_self">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java:Annotation(注解)--原理到案例</h1><p class="post-info"><i class="fa fa-calendar">&nbsp;</i>2019-03-24&nbsp;| <i class="fa fa-tags">&nbsp;</i><a class="post-tag-link" href="/tags/%E5%8E%9F%E7%90%86/">原理&nbsp;·&nbsp;</a>&nbsp;| <i class="fa fa-folder-o">&nbsp;</i><a class="post-category-link" href="/categories/program/">program&nbsp;/&nbsp;</a><a class="post-category-link" href="/categories/program/JAVA/">JAVA&nbsp;/&nbsp;</a></p><div class="post-content"><h2 id="1-Annotation为何而来"><a href="#1-Annotation为何而来" class="headerlink" title="1.Annotation为何而来"></a>1.Annotation为何而来</h2><ol>
<li> JDK5开始，java增加了对元数据(MetaData)的支持，通过Annotation(注解）来实现。Annotation提供了为程序元素设置元数据的方法。**<a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=etK4p_wPODnDqBcUaZKGj2yv09H-jtTdjEwY8Ou2W_-U3OqW_xMfJsKMks1wuyKQjLVIGqCjT7e_nNX4q-QKj_J7aS5OUCS6YGDDUyJ-eOHCYxihaCV7kL-J_zAnWPjF">元数据</a>：描述数据的数据。**</li>
<li> <strong>Annotation可以设置元数据程序元素：</strong>包括修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。元数据的信息被存储在Annotation的“name=value”对中。</li>
<li> <strong>程序使用方式</strong>：数据的信息被存储在Annotation的“name=value”对中。Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象，然后通过Annotation对象来取得注解里的元数据。</li>
<li> Annotation不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一的执行。如果希望让程序中的Annotation在运行时起一定的作用，只有通过某种配套工具对Annotation中的信息进行访问和处理。<strong>jdk7之前访问和处理Annotation的工具统称APT（Annotation Processing Tool)(jdk7后就被废除了），jdk7及之后采用了JSR 269 API。相关原因<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/">官方说明</a> 、 <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/117">原因</a></strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy=GenerationType.AUTO)</span><br><span class="line">    private Long uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用Annotation"><a href="#为什么使用Annotation" class="headerlink" title="为什么使用Annotation"></a>为什么使用Annotation</h2><ol>
<li>  Annotation就像代码里的特殊标记，这些标记可以在<strong>编译、类加载、运行时</strong>被读取。读取到了程序元素的元数据，就可以执行相应的处理。通过注解，程序开发人员可以在不改变原有逻辑的情况下，在源代码文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过解析这些注解获取到这些补充信息，从而进行验证或者进行部署等。</li>
<li> 有些注解只是为了防止我们犯低级错误，通过这些注解，让编译器在编译期就可以检查出一些低级错误，对于这些注解，可以加或者不加，当然还有很多其他注解都是起辅助编程作用。但是有一些注解的作用很重要，不加的话就实现不了一些功能，比如，数据持久化操作中，通过@Entity注解来标识持久化实体类，如果不使用该注解程序就识别不了持久化实体类。</li>
</ol>
<p> </p>
<h2 id="二-基本Annotation"><a href="#二-基本Annotation" class="headerlink" title="二. 基本Annotation"></a>二. 基本Annotation</h2><blockquote>
<p>Java提供了5个基本的Annotation</p>
</blockquote>
<ol>
<li> @Override ：限定重写父类方法，它可以强制一个子类必须覆盖父类的方法。<strong>写在子类的方法上</strong>，在编译期，编译器检查这个方法，检查父类必须包含该方法，否则编译出错。该注解只能修饰方法，在编译期被读取。</li>
<li> @Deprecated：用于表示某个程序元素（类、方法等）已过时。编译时读取，编译器编译到过时元素会给出警告。</li>
<li>@SuppressWarnings：抑制编译警告，被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译警告。<br> 比如：如果程序使用没有泛型限制的集合会引起编译器警告，为了避免这种警告可以使用该注解<ol>
<li>  @SuppressWarnings(value=”unchecked”) unchecked异常：运行时异常。是RuntimeException的子类，不需要在代码中显式地捕获unchecked异常做处理。</li>
<li>  @SuppressWarnings(“deprecation”)</li>
</ol>
</li>
<li> @SafeVarargs (java7新增）：去除“堆污染”警告</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/palmtale/article/details/9302711">堆污染</a>：把一个不带泛型的对象赋给一个带泛型的变量时就会发生堆污染。<br>例如：下面代码引起堆污染，会给出警告</p>
<p>List l2 = new ArrayList();<br>List ls = l2;    </p>
<p>三种方式去掉上面方法产生的警告<br>1.使用注解@SafeVarargs修饰引发该警告的方法或构造器。<br>2.使用@SuppressWarnings(“unchecked”) 修饰。<br>3.使用编译器参数命令：-Xlint:varargs</p>
<p> 5.  @Functionlnterface （java8新增）：修饰函数式接口</p>
<ul>
<li>使用该注解修饰的接口必须是函数式接口，不然编译会出错。那么什么是函数式接口？答：如果接口中只有一个抽象方法（可以包含多个default方法或static方法），就是函数式接口。<br>  如：</li>
</ul>
<p>@Functionlnterface<br>public interface FunInterface{<br>  static void foo(){<br>      System.out.println(“foo类方法”); }<br>  default void bar(){<br>      System.out.println(“bar默认方法”); }<br>  void test();//只定义一个抽象方法，默认public<br>}</p>
<h2 id="三-JDK元Annotation-修饰注解的注解"><a href="#三-JDK元Annotation-修饰注解的注解" class="headerlink" title="三. JDK元Annotation(修饰注解的注解)"></a>三. JDK元Annotation(修饰注解的注解)</h2><ul>
<li>  元注解(Meta Annotation)：和元数据一样，<strong>修饰注解的注解</strong>。</li>
<li>  java提供了6个元注解（Meta Annotation)，在java.lang.annotation中。<strong>其中5个用于修饰其他的Annonation定义</strong>。而@Repeatable专门用于定义Java8新增的重复注解。所以要定义注解必须使用到5个元注解来定义。</li>
</ul>
<h2 id="Retention（英文：保留）"><a href="#Retention（英文：保留）" class="headerlink" title="@Retention（英文：保留）"></a>@Retention（英文：保留）</h2><ul>
<li>  用于指定被修饰的Annotation可以保留多长时间，只能修饰Annotation定义。@Retention包含一个RetentionPolicy类型的value成员变量，使用@Retention必须为该value成员变量指定值。value成员变量的值有3个选择：</li>
<li>  RetentionPolicy.CLASS:编译器将把Annotation记录在class文件中。当运行java程序时，JVM不可获取Annotation信息。（默认值）</li>
<li>  RetentionPolicy.RUNTIME:编译器将把Annotation记录在class文件中。当运行java程序时，JVM也可获取Annotation信息，程序可以通过反射获取该Annotation信息</li>
<li>RetentionPolicy.SOURCE:Annotation只保留在源代码中（.java文件中），编译器直接丢弃这种Annotation。<br>  案例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//定义下面的Testable Annotation保留到运行时，也可以使用value=RetentionPolicy.RUNTIME</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Testable&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Target-目标"><a href="#Target-目标" class="headerlink" title="@Target ( 目标)"></a>@Target ( 目标)</h2><p>用于指定被修饰的Annotation能用于修饰哪些程序单元，只能修饰Annotation定义。它包含一个名为value的成员变量，取值如下：</p>
<ul>
<li>  @Target(ElementType.ANNOTATION_TYPE)：指定该该策略的Annotation只能修饰Annotation.</li>
<li>  @Target(ElementType.TYPE) //接口、类、枚举、注解</li>
<li>  @Target(ElementType.FIELD) //成员变量（字段、枚举的常量）</li>
<li>  @Target(ElementType.METHOD) //方法</li>
<li>  @Target(ElementType.PARAMETER) //方法参数</li>
<li>  @Target(ElementType.CONSTRUCTOR) //构造函数</li>
<li>  @Target(ElementType.LOCAL_VARIABLE)//局部变量</li>
<li>  @Target(ElementType.PACKAGE) ///修饰包定义</li>
<li>  @Target(ElementType.TYPE_PARAMETER) //java8新增，后面Type Annotation有介绍</li>
<li>  @Target(ElementType.TYPE_USE) ///java8新增，后面Type Annotation有介绍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface ActionListenerFor&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><ul>
<li>  用于指定被修饰的Annotation将被javadoc工具提取成文档。即说明该注解将被包含在javadoc中。</li>
</ul>
<h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><ul>
<li>  用于指定被修饰的Annotation具有继承性。即子类可以继承父类中的该注解。—》注解@WW被元注解@Inherited修饰，把@WW添加在类Base上，则Base的所有子类也将默认使用@WW注解。</li>
</ul>
<h1 id="5-自定义注解"><a href="#5-自定义注解" class="headerlink" title="5.自定义注解"></a>5.自定义注解</h1><ul>
<li>  使用@interface关键字</li>
<li>  注解放在修饰元素的上面</li>
<li><h2 id="5-1一个简单的注解"><a href="#5-1一个简单的注解" class="headerlink" title="5.1一个简单的注解"></a>5.1一个简单的注解</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义一个简单的注解Test</span><br><span class="line">public @interface Test&#123;&#125;</span><br></pre></td></tr></table></figure>
  默认情况下，Annotation可以修饰任何程序元素:类、接口、方法等。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public class MyClass&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2带成员变量的注解"><a href="#5-2带成员变量的注解" class="headerlink" title="5.2带成员变量的注解"></a>5.2带成员变量的注解</h2><ul>
<li>  以无形参的方法形式来声明Annotation的成员变量，方法名和返回值定义了成员变量名称和类型。使用default关键字设置初始值。没设置初始值的变量则使用时必须提供，有初始值的变量可以设置也可以不设置。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义带成员变量注解MyTag</span><br><span class="line">@Rentention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface MyTag&#123;</span><br><span class="line">  //定义两个成员变量，以方法的形式定义</span><br><span class="line">  String name();</span><br><span class="line">  int age() default 32;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">public class Test&#123;</span><br><span class="line">  @MyTag(name=&quot;liang&quot;)</span><br><span class="line">  public void info()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3结论"><a href="#5-3结论" class="headerlink" title="5.3结论"></a>5.3结论</h2><ul>
<li>  没带成员变量的Annotation被称为标记，这种注解仅利用自身的存在与否来提供信息，如@Override等。</li>
<li>  包含成员变量的Annotation称为元数据Annotation,因为他们提供更多元数据。</li>
</ul>
<h2 id="5-4提取Annotation信息"><a href="#5-4提取Annotation信息" class="headerlink" title="5.4提取Annotation信息"></a>5.4提取Annotation信息</h2><ul>
<li>使用Annotation修饰了类、方法、成员变量等程序元素之后，这些Annotation不会自己生效，必须由开发者通过API来提取并处理Annotation信息。</li>
<li>Annotation接口是所有注解的父接口。</li>
<li><strong>思路：</strong>通过反射获取Annotation，将Annotation转换成具体的注解类，在调用注解类定义的方法获取元数据信息。</li>
<li><em>获取Annotation</em>*</li>
<li>AnnotatedElement接口(java.lang.reflect反射包中)代表程序中可以接受注解的程序元素。即所有可以接受注解的程序元素都会实现该接口。而该接口就提供了获取Annotation的方法，它的所有实现类也便拥有了这些方法。常见的实现类：</li>
<li>Class:类定义。</li>
<li>Constructor:构造器定义</li>
<li>Field:类的成员变量定义</li>
<li>Method:类的方法定义。</li>
<li>Package:类的包定义。</li>
<li>由此可见，AnnotatedElement接口的实现类都是一些反射技术设计到的类，所以访问Annotation信息也是通过反射技术来实现的。</li>
<li>java.lang.reflect包下还包含实现反射功能的工具类，java5开始，java.lang.reflect包提供的反射API增加了读取允许Annotation的能力。但是，<em><em>只有定义Annotation时使用了@Rentention(RetentionPolicy.RUNTIME)修饰，该Annotation才会在运行时可见，JVM才会在装载</em>.class文件时读取保存在class文件中的Annotation</em>*。</li>
<li>AnnotatedElement接口获取Annotation信息的方法：</li>
<li><T extends Annotation> T getAnnotation(Class<T> annotationClass)：返回修饰该程序元素的指定类型的注解，不存在则返回 null。</li>
<li><T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)：返回直接修饰该程序元素的指定类型的注解，不存在则返回 null。 （java8新增）</li>
<li>Annotation[] getAnnotations()：返回此元素上存在的所有注解。</li>
<li>Annotation[] getDeclaredAnnotations()：返回<strong>直接</strong>存在于此元素上的所有注解。</li>
<li>boolean isAnnotationPresent (Class&lt; ? extends Annotation&gt; annotationClass)：如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。<br>  java8新增了重复注解功能，所以下面两个方法在java8之后才有：</li>
<li><T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)：返回修饰该程序元素的指定类型的多个注解，不存在则返回 null。</li>
<li><T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)：返回直接修饰该程序元素的指定类型的多个注解，不存在则返回 null。</li>
<li><strong>案例</strong></li>
<li>需求：获取Test类的info方法上的所有注解，并打印出来，如果包含MyTag注解，则再输出MyTag注解的元数据。</li>
<li>  实现：正如我们所知，仅在程序中使用注解是不起任何作用的，必须使用注解处理工具来处理程序中的注解。下面就写一个注解处理类。处理注解的思路如下：通过反射获取Test的类描述类Class，然后在获取其info方法描述类Method，因为Method实现了AnnotatedElement接口，所以调用getAnnotations方法获取所有注解，在遍历打印。</li>
</ul>
  MyTag注解处理器  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyTagAnnotationProcessor &#123;</span><br><span class="line">    public static void process(String className) throws ClassNotFoundException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">             Class clazz =Class.forName(className);</span><br><span class="line">             Annotation[] aArray= clazz.getMethod(&quot;info&quot;).getAnnotations();</span><br><span class="line">             for( Annotation an :aArray)&#123;</span><br><span class="line">                 System.out.println(an);//打印注解</span><br><span class="line">                 if( an instanceof MyTag)&#123;</span><br><span class="line">                     MyTag tag = (MyTag) an;</span><br><span class="line">                     System.out.println(&quot;tag.name():&quot;+tag.name());</span><br><span class="line">                     System.out.println(&quot;tag.age():&quot;+tag.age());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  场景测试  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyTagAnnotationProcessor.process(&quot;annotation.Test&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
  测试结果  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@annotation.MyTag(age=25, name=liang)</span><br><span class="line">tag.name():liang</span><br><span class="line">tag.age():25</span><br></pre></td></tr></table></figure>
<h1 id="6-使用Annotation示例"><a href="#6-使用Annotation示例" class="headerlink" title="6.使用Annotation示例"></a>6.使用Annotation示例</h1><ul>
<li>  想找spring中关于注解定义、使用、注解处理的代码，注解处理的代码没找到，不知道在哪个类中。</li>
</ul>
<h1 id="7-Java8新增的重复注解"><a href="#7-Java8新增的重复注解" class="headerlink" title="7.Java8新增的重复注解"></a>7.Java8新增的重复注解</h1><ul>
<li>  在java8以前，同一个程序元素只能使用一个相同类型的Annotation。如下代码是错误的。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//代码错误，不可以使用相同注解在一个程序元素上。</span><br><span class="line"> @MyTag(name=&quot;liang&quot;)</span><br><span class="line">@MyTag(name=&quot;huan&quot;)</span><br><span class="line">public void info()&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-1-java8之前实现思路"><a href="#7-1-java8之前实现思路" class="headerlink" title="7.1 java8之前实现思路"></a>7.1 java8之前实现思路</h2><ul>
<li>要想达到使用多个注解的目的，可以使用注解”容器“：其实就是新定义一个注解DupMyTag ，让这个DupMyTag 注解的成员变量value的类型为注解MyTag数组。这样就可以通过注解DupMyTag 使用多个注解MyTag了。换个思路实现，只是书写形式不一样而已。</li>
<li><em>操作步骤2步：1编写需要重复的注解@MyTag，上面定义过了。2.编写”容器“注解DupMyTag 。</em>*</li>
<li>  如下DupMyTag 注解：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=ElementType.METHOD)</span><br><span class="line">public @interface DupMyTag &#123;</span><br><span class="line">    //成员变量为MyTag数组类型</span><br><span class="line">    MyTag[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  使用@DupMyTag，为@DupMyTag 注解的成员变量设置多个@MyTag注解，从而达到效果。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//代码正确，换个思路实现，在同一个程序元素上使用了多个相同的注解MyTag</span><br><span class="line"> @DupMyTag (&#123; @MyTag(name=&quot;liang&quot;),@MyTag(name=&quot;huan&quot;,age=18)&#125;)</span><br><span class="line">public void info()&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
  打印注解输出内容如下：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@annotation.DupMyTag(value=[@annotation.MyTag(age=25, name=liang), @annotation.MyTag(age=18, name=huan)])</span><br></pre></td></tr></table></figure>
<hr>
  <strong>结论：通过新定义一个容器注解，来实现使用多个相同注解的目的，只是书写形式不能达到期待效果而已，要想书写形式能达到期待效果需要使用java8之后的@Repeatable元注解。</strong>  <strong>注：”容器“注解的保留期Retention必须比它所包含注解的保留期更长，否则编译报错</strong><h2 id="7-2-java8之后"><a href="#7-2-java8之后" class="headerlink" title="7.2 java8之后"></a>7.2 java8之后</h2><ul>
<li>java8之后新增了@Repeatable元注解，用来开发重复注解，其有一个必填Class类型变量value。</li>
<li>同样，还是需要新定义一个注解@DupMyTag。和上面定义的一样。不一样的是@Repeatable元注解需要加在@MyTag上，value值设置为DupMyTag.class，开发便完成。</li>
<li><em>操作步骤2步：1编写需要重复的注解@MyTag，如下。2.编写”容器“注解DupMyTag ，上面定义过了</em>*</li>
<li>  如下：通过@Repeatable定义了一个重复注解@MyTag。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//定义带成员变量注解MyTag</span><br><span class="line">@Repeatable(DupMyTag.class)</span><br><span class="line">@Rentention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Method(ElementType.METHOD)</span><br><span class="line">public @interface MyTag&#123;</span><br><span class="line">  //定义两个成员变量，以方法的形式定义</span><br><span class="line">  String name();</span><br><span class="line">  int age() default 32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  使用,书写形式达到了理想效果，当然上面的形式依然可以使用</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@MyTag(name=&quot;liang&quot;)</span><br><span class="line">@MyTag(name=&quot;huan&quot;,age =18)</span><br><span class="line">public void info()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//两种形式都可以</span><br><span class="line">@DupMyTag (&#123; @MyTag(name=&quot;liang&quot;),@MyTag(name=&quot;huan&quot;,age=18)&#125;)</span><br><span class="line">public void info()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原理：系统依然还是将两个MyTag注解作为DupMyTag的value成员变量的数组元素，只是书写形式多了一种而已</strong></li>
<li><strong>获取注解方法</strong><br>  上面代码通过getDeclaredAnnotationsByType(MyTag.class)和getDeclaredAnnotation(DupMyTag.class)两个方法都能获取到值，只是结果不一样如下：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@annotation.MyTag(age=25, name=liang)</span><br><span class="line">@annotation.MyTag(age=18, name=huan)</span><br><span class="line">@annotation.DupMyTag(value=[@annotation.MyTag(age=25, name=liang), @annotation.MyTag(age=18, name=huan)])</span><br></pre></td></tr></table></figure>
<h1 id="8-Java8新增的Type-Annotation注解"><a href="#8-Java8新增的Type-Annotation注解" class="headerlink" title="8. Java8新增的Type Annotation注解"></a>8. Java8新增的Type Annotation注解</h1><h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h2><ul>
<li><strong>目的</strong>：以前的注解只能用在包、类、构造器、方法、成员变量、参数、局部变量。如果想在：创建对象（通过new创建）、类型转换、使用implements实现接口、使用throws声明抛出异常的位置使用注解就不行了。而Type Annotation注解就为了这个而来。</li>
<li>  <strong>抽象表述：</strong> java_为ElementType枚举增加了TYPE_PARAMETER、TYPE_USE两个枚举值。@Target(TYPE_USE)修饰的注解称为Type Annotation(类型注解），_<em>Type Annotation可用在任何用到类型的地方。</em>*</li>
</ul>
<h2 id="8-2-案例"><a href="#8-2-案例" class="headerlink" title="8.2 案例"></a>8.2 案例</h2><ul>
<li>  定义一个类型注解NotNull</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE_USE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface NotNull &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  使用</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//implements实现接口中使用Type Annotation</span><br><span class="line">public class Test implements @NotNull(value=&quot;Serializable&quot;) Serializable&#123;</span><br><span class="line">        //泛型中使用Type Annotation  、   抛出异常中使用Type Annotation</span><br><span class="line">    public  void foo(List&lt;@NotNull String&gt; list) throws @NotNull(value=&quot;ClassNotFoundException&quot;) ClassNotFoundException &#123;</span><br><span class="line">        //创建对象中使用Type Annotation</span><br><span class="line">        Object obj =new @NotNull String(&quot;annotation.Test&quot;);</span><br><span class="line">        //强制类型转换中使用Type Annotation</span><br><span class="line">        String str = (@NotNull String) obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写处理注解的处理器。</li>
<li>java8提供AnnotatedType接口，该接口用来代表被注解修饰的类型。该接口继承AnnotatedElement接口。同时多了一个public Type getType()方法，用于返回注解修饰的类型。</li>
<li>  以下处理器只处理了类实现接口处的注解和throws声明抛出异常处的注解。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">类说明 NotNull注解处理器，只处理了implements实现接口出注解、throws声明抛出异常出的注解。</span><br><span class="line">*/</span><br><span class="line">public class NotNullAnnotationProcessor &#123;</span><br><span class="line">    public static void process(String className) throws ClassNotFoundException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz =Class.forName(className);</span><br><span class="line">            //获取类继承的、带注解的接口</span><br><span class="line">            AnnotatedType[] aInterfaces =clazz.getAnnotatedInterfaces();</span><br><span class="line">            print(aInterfaces);</span><br><span class="line">            Method method = clazz.getMethod(&quot;foo&quot;);</span><br><span class="line">            //获取方法上抛出的带注解的异常</span><br><span class="line">            AnnotatedType[] aExceptions =method.getAnnotatedExceptionTypes();</span><br><span class="line">            print(aExceptions);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 打印带注解类型</span><br><span class="line">     * @param array</span><br><span class="line">     */</span><br><span class="line">    public static void print(AnnotatedType[] array)&#123;</span><br><span class="line">        for( AnnotatedType at : array)&#123;</span><br><span class="line">            Type type =at.getType();//获取基础类型</span><br><span class="line">            Annotation[] ans =at.getAnnotations();//获取注解</span><br><span class="line">            //打印类型</span><br><span class="line">            System.out.println(type);</span><br><span class="line">            //打印注解</span><br><span class="line">            for( Annotation an : ans)&#123;</span><br><span class="line">                System.out.println(an);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  打印结果  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface java.io.Serializable</span><br><span class="line">@annotation.NotNull(value=Serializable)</span><br><span class="line">------------</span><br><span class="line">class java.lang.ClassNotFoundException</span><br><span class="line">@annotation.NotNull(value=ClassNotFoundException)</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>
<h1 id="9-编译时处理Annotation"><a href="#9-编译时处理Annotation" class="headerlink" title="9. 编译时处理Annotation"></a>9. 编译时处理Annotation</h1><h2 id="9-1-需求"><a href="#9-1-需求" class="headerlink" title="9.1 需求"></a>9.1 <strong>需求</strong></h2><ul>
<li>  有过Hibernate开发经验的朋友可能知道每写一个Java文件，还必须额外地维护一个Hibernate映射文件(一个名为*.hbm.xml的文件,当然可以有一些工具可以自动生成)下面将使用Annotation来简化这步操作。思路：自定义修饰类的注解，在实体类上使用注解，编写注解处理器：根据源文件中的类上的注解，生成*.hbm.xml文件，使用java提供的编译命令javac执行注解处理器。关键：编写注解处理器。</li>
</ul>
<h2 id="9-2可用api"><a href="#9-2可用api" class="headerlink" title="9.2可用api"></a>9.2<strong>可用api</strong></h2><ul>
<li>  我们知道前面的注解处理器处理的都是@Retention(RetentionPolicy.RUNTIME)的注解，使用的是反射技术。而生成的*hbm.xml文件是需要在编译阶段完成。为此java在java7之前提供了apt工具及api，在java7及之后提供了JSR269 api。</li>
</ul>
<h2 id="9-3-apt和jsr269的作用"><a href="#9-3-apt和jsr269的作用" class="headerlink" title="9.3 apt和jsr269的作用"></a>9.3 apt和jsr269的作用</h2><ul>
<li>  APT是一种处理注释的工具,它对源代码文件进行检测，并找出源文件中所包含的Annotation信息，然后针对Annotation信息进行额外的处理。</li>
<li>  APT处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件.使用APT主要的目的是简化开发者的工作量。</li>
<li>  因为APT可以编译程序源代码的同时，生成一些附属文件(比如源文件、类文件、程序发布描述文件等)，这些附属文件的内容也都是与源代码相关的，换句话说，使用APT可以代替传统的对代码信息和附属文件的维护工作。</li>
<li>APT的相关api都在com.sun.mirror 包下，在jdk7及之后，apt的相关api就被废除了，代替的是<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/platform?listBy=2&listByType=platform">JSR</a>269。JSR269<a target="_blank" rel="noopener" href="http://download.oracle.com/otndocs/jcp/pluggable_annotation_processing-1_8-mrel2-eval-spec/index.html">API文档下载</a>。JSR269的api在 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/package-summary.html">javax.annotation.processing</a> and <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/package-summary.html">javax.lang.model</a>包下。<br>  所以以后开发注解处理器使用jsr269提供的api就可以了。 <img src="//upload-images.jianshu.io/upload_images/3458176-743496641f19c61b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">JSR269描述</li>
</ul>
<h2 id="9-4实现"><a href="#9-4实现" class="headerlink" title="9.4实现"></a>9.4实现</h2><h3 id="9-5-使用apt实现"><a href="#9-5-使用apt实现" class="headerlink" title="9.5 使用apt实现"></a>9.5 使用apt实现</h3>  <a target="_blank" rel="noopener" href="http://www.javacui.com/Theory/367.html">使用apt实现编译时处理Annotation</a><h3 id="9-6-使用JSR269实现"><a href="#9-6-使用JSR269实现" class="headerlink" title="9.6 使用JSR269实现"></a>9.6 使用JSR269实现</h3><ul>
<li>运行环境jdk1.8</li>
<li>Java提供的javac.exe工具有一个-processor选项，该选项可指定一个Annotation处理器，如果在编译java源文件的时候通过该选项指定了Annotation处理器，那么这个Annotation处理器，将会在编译时提取并处理Java源文件中的Annotation。</li>
<li>每个Annotation处理器都需要实现javax.annotation.processing包下的Processor接口。不过实现该接口必须实现它里面所有方法，因此通常采用继承AbstractProcessor的方式来实现Annotation处理器，一个Annotation处理器可以处理一种或多种Annotation类型。</li>
<li><strong>之前的错误认识</strong>：之前以为-processor选项需要指定注解处理器是一个*.java文件，其实是一个.class文件，既然是.class文件，那么肯定是编译过后的，所以需要单独写一个处理器程序annotation-processor，打成一个jar包，然后在使用注解的程序annotation中加入注解处理器依赖包annotation-processor.jar，在编译的时候指定处理器类即可。下面我会分别演示通过javac 命令和maven命令如何进行操作。</li>
<li>下面的项目会使用maven来构建，如果不是使用maven也可以，因为我也会演示如何通过javac 命令来执行注解处理器。</li>
</ul>
<hr>
<h4 id="9-6-1-注解处理器程序annotation-processor"><a href="#9-6-1-注解处理器程序annotation-processor" class="headerlink" title="9.6.1 注解处理器程序annotation-processor"></a>9.6.1 注解处理器程序annotation-processor</h4><ul>
<li>  下面将定义三个Annotation类型，分别用于修饰持久化类，标识属性和普通属性。</li>
</ul>
  修饰id注解  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.processor.annotation;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">//修饰id注解</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">    String column();    //该id属性对应表中的列名</span><br><span class="line">    String type();      //id属性类型</span><br><span class="line">    String generator(); //使用的策略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  修饰属性注解  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.processor.annotation;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">//修饰属性注解</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Property &#123;</span><br><span class="line">    String column();    //该属性对应表中的列名</span><br><span class="line">    String type();      //id属性类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  修饰实体类注解  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.processor.annotation;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">//修饰实体类注解</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Persistent &#123;</span><br><span class="line">    String table();       //数据库中表名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  处理上面三个注解的处理器HibernateAnnotationProcessor，根据注解生成对应的*.hbm.xml文件</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.processor;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import javax.annotation.processing.AbstractProcessor;</span><br><span class="line">import javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line">import javax.annotation.processing.RoundEnvironment;</span><br><span class="line">import javax.lang.model.SourceVersion;</span><br><span class="line">import javax.lang.model.element.Element;</span><br><span class="line">import javax.lang.model.element.ElementKind;</span><br><span class="line">import javax.lang.model.element.Name;</span><br><span class="line">import javax.lang.model.element.TypeElement;</span><br><span class="line">import com.zlcook.processor.annotation.Id;</span><br><span class="line">import com.zlcook.processor.annotation.Persistent;</span><br><span class="line">import com.zlcook.processor.annotation.Property;</span><br><span class="line">/**</span><br><span class="line">* 类说明:hiberante注解处理器，用于根据实体bean的注解生成*.hbm.xml文件，在编译阶段执行。</span><br><span class="line">*/</span><br><span class="line">public class HibernateAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line">        System.out.println(&quot;HibernateAnnotationProcessor注解处理器初始化完成..............&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        //定义一个文件输出流，用于生成额外的文件</span><br><span class="line">        PrintStream ps = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            //遍历每个被@Persistent修饰的class文件,使用RoundEnvironment来获取Annotation信息</span><br><span class="line">            for( Element t : roundEnv.getElementsAnnotatedWith(Persistent.class))&#123;</span><br><span class="line">                //获取正在处理的类名</span><br><span class="line">                Name clazzName = t.getSimpleName();</span><br><span class="line">                //获取类定义前的@Persistent Annotation</span><br><span class="line">                Persistent per = t.getAnnotation(Persistent.class);</span><br><span class="line">                //创建文件输出流</span><br><span class="line">                String fileName =clazzName+&quot;.hbm.xml&quot;;</span><br><span class="line">                ps = new PrintStream(new FileOutputStream(fileName));</span><br><span class="line">                 // 执行输出</span><br><span class="line">                 ps.println(&quot;&lt;?xml version=&quot;1.0&quot;?&gt;&quot;);</span><br><span class="line">                 ps.println(&quot;&lt;!DOCTYPE hibernate-mapping&quot;);</span><br><span class="line">                 ps.println(&quot; PUBLIC &quot;-// Hibernate/Hibernate Ma  pping DTD 3.0//EN&quot;&quot;);</span><br><span class="line">                 ps.println(&quot; &quot;http:// hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&quot;);</span><br><span class="line">                 ps.println(&quot;&lt;hibernate-mapping&gt;&quot;);</span><br><span class="line">                 ps.print(&quot; &lt;class name=&quot;&quot; + t);</span><br><span class="line">                 // 输出per的table()的值</span><br><span class="line">                 ps.println(&quot;&quot; table=&quot;&quot; + per.table() + &quot;&quot;&gt;&quot;);</span><br><span class="line">                 //获取@Persistent修改类的各个属性字段。t.getEnclosedElements()获取该Elemet里定义的所有程序单元</span><br><span class="line">                 for(Element ele : t.getEnclosedElements())&#123;</span><br><span class="line">                     //只处理成员变量上的Annotation，ele.getKind()返回所代表的的程序单元</span><br><span class="line">                     if( ele.getKind() == ElementKind.FIELD)&#123;</span><br><span class="line">                        //被id注解修饰的字段</span><br><span class="line">                         Id idAno= ele.getAnnotation(Id.class);</span><br><span class="line">                         if( idAno != null)&#123;</span><br><span class="line">                             String column =idAno.column();</span><br><span class="line">                             String type =idAno.type();</span><br><span class="line">                             String generator = idAno.generator();</span><br><span class="line">                             // 执行输出</span><br><span class="line">                               ps.println(&quot; &lt;id name=&quot;&quot; + ele.getSimpleName() + &quot;&quot; column=&quot;&quot; + column + &quot;&quot; type=&quot;&quot; + type + &quot;&quot;&gt;&quot;);</span><br><span class="line">                               ps.println(&quot; &lt;generator class=&quot;&quot; + generator + &quot;&quot;/&gt;&quot;);</span><br><span class="line">                               ps.println(&quot; &lt;/id&gt;&quot;);</span><br><span class="line">                         &#125;</span><br><span class="line">                         //被Property注解修饰的字段</span><br><span class="line">                         Property p = ele.getAnnotation(Property.class);</span><br><span class="line">                         if( p !=null)&#123;</span><br><span class="line">                             // 执行输出</span><br><span class="line">                             ps.println(&quot; &lt;property name=&quot;&quot; + ele.getSimpleName() + &quot;&quot; column=&quot;&quot; + p.column() + &quot;&quot;type=&quot;&quot; + p.type() + &quot;&quot;/&gt;&quot;);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;// end for</span><br><span class="line">                 ps.println(&quot; &lt;/class&gt;&quot;);</span><br><span class="line">                 ps.println(&quot;&lt;/hibernate-mapping&gt;&quot;);</span><br><span class="line">            &#125;// end for </span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(ps!=null)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    /** </span><br><span class="line">     * 这里必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称 </span><br><span class="line">     * @return  注解器所支持的注解类型集合，如果没有这样的类型，则返回一个空集合 </span><br><span class="line">     */  </span><br><span class="line">    @Override  </span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;  </span><br><span class="line">        Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;();  </span><br><span class="line">        annotataions.add(Id.class.getCanonicalName());  </span><br><span class="line">        annotataions.add(Property.class.getCanonicalName());  </span><br><span class="line">        annotataions.add(Persistent.class.getCanonicalName());  </span><br><span class="line">        return annotataions;  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 指定使用的Java版本，通常这里返回SourceVersion.latestSupported()，默认返回SourceVersion.RELEASE_6 </span><br><span class="line">     * @return  使用的Java版本 </span><br><span class="line">     */</span><br><span class="line">    @Override  </span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;  </span><br><span class="line">        return SourceVersion.latestSupported();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注解程序写完打包成jar文件。</strong></li>
<li>打包成jar文件为使用注解处理器的程序提供依赖。</li>
<li>使用maven构建直接使用mvn install，这样就将项目打包成jar依赖到本地仓库中了。</li>
<li>使用java命令打包成jar文件：先用javac编译成.class文件，在使用jar命令打包成jar文件。</li>
<li><strong>使用java命令打包成jar文件</strong></li>
<li>源文件位置：E:EclipseWorkspaceCnuannotation-processorsrcmainjava，编译后*.class文件存放到classes文件夹下，使用javac命令编译源代码需要指定*.java文件，为了避免在命令行中敲太多代码，所以将要编译的源代码文件都列在了sources.list文件中。 <img src="//upload-images.jianshu.io/upload_images/3458176-ffbecd706295b740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp">源代码文件及编译后文件存放位置 <img src="//upload-images.jianshu.io/upload_images/3458176-40073127e22f416b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/530/format/webp">source.list文件内容</li>
<li>执行编译命令javac<br>  javac命令中指定UTF-8编码、编译后文件存放位置、需要编译的源文件</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:EclipseWorkspaceCnuannotation-processorsrcmainjava&gt;javac -encoding UTF-8</span><br><span class="line"> -d classes @sources.list</span><br></pre></td></tr></table></figure>
<ul>
<li>执行打包命令jar<br>  将classes中的编译文件，打包成annotation-processor.jar文件。进入到<strong>classes目录中</strong>执行如下jar命令</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:EclipseWorkspaceCnuannotation-processorsrcmainjavaclasses&gt;jar -cvf annotation-processor.jar com</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="9-6-2-注解使用程序annotation"><a href="#9-6-2-注解使用程序annotation" class="headerlink" title="9.6.2 注解使用程序annotation"></a>9.6.2 注解使用程序annotation</h4><ul>
<li>  <strong>添加annotation-processor.jar依赖</strong></li>
<li>  注解处理程序写完并打成了jar包，将jar引入到annotation中使用。</li>
<li>  使用maven则在pom.xml中声明一个依赖。因为该依赖只在编译阶段才使用所以范围采用provied。更多<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/79cf4423281a">maven依赖范围</a></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.zlcook.processor&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;annotation-processor&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;0.0.5-SNAPSHOT&lt;/version&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有使用maven构建，只要保证运行项目时annotation-processor.jar在classpath路径中就行。根据你是用的开发工具而定，使用eclipse则将jar添加到编译路径中。</li>
<li><strong>编写项目annotation</strong></li>
<li>  为了演示自定义注解和注解处理的作用：在编译时根据注解生成*.hbm.xml文件。所以写一个类Person就可以了。代码如下：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.zlcook.annotation.bean;</span><br><span class="line">import com.zlcook.processor.annotation.Id;</span><br><span class="line">import com.zlcook.processor.annotation.Persistent;</span><br><span class="line">import com.zlcook.processor.annotation.Property;</span><br><span class="line">/**</span><br><span class="line">* @author 周亮 </span><br><span class="line">* @version 创建时间：2017年2月19日 下午10:05:05</span><br><span class="line">* 类说明:使用注解完成映射的实体类</span><br><span class="line">*/</span><br><span class="line">@Persistent(table=&quot;person_inf&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">     @Id(column = &quot;person_id&quot;, type = &quot;integer&quot;, generator = &quot;identity&quot;)</span><br><span class="line">     private int id;</span><br><span class="line">     @Property(column = &quot;person_name&quot;, type = &quot;string&quot;)</span><br><span class="line">     private String name;</span><br><span class="line">     @Property(column = &quot;person_age&quot;, type = &quot;integer&quot;)</span><br><span class="line">     private int age;</span><br><span class="line">     public int getId() &#123;</span><br><span class="line">      return id;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setId(int id) &#123;</span><br><span class="line">      this.id = id;</span><br><span class="line">     &#125;</span><br><span class="line">     public String getName() &#123;</span><br><span class="line">      return name;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     public int getAge() &#123;</span><br><span class="line">      return age;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setAge(int age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-6-3-运行效果演示"><a href="#9-6-3-运行效果演示" class="headerlink" title="9.6.3 运行效果演示"></a>9.6.3 运行效果演示</h4><ul>
<li>下面就使用javac命令和maven命令编译annotation项目，来演示HibernateAnnotationProcessor处理器的效果。看能不能在编译期生成Person.hbm.xml文件。</li>
<li><strong>javac编译</strong><ul>
<li>将annotation-processor.jar拷贝到annotaion的源代码位置，当然你也可以拷贝到其它地方，主要为了引用方便。再新建一个存放编译文件的文件夹classes。如下：   <img src="//upload-images.jianshu.io/upload_images/3458176-13ba4e03c5981291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp">编译器文件情况</li>
</ul>
</li>
<li>在该目录下执行javac 命令<br>  javac命令中指定UTF-8编码、编译后文件存放位置、编译过程中依赖的文件、注解处理器类、需要编译的源文件</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:EclipseWorkspaceCnuannotationsrcmainjava&gt;javac -encoding UTF-8 -d classes -classpath annotation-processor.jar -processor com.zlcook.processor.HibernateAnnotationProcessor com/zlcook/annotation/bean/Person.java</span><br></pre></td></tr></table></figure>
<ul>
<li>执行后效果<br>  当前目录下出现了一个Person.hbm.xml文件   <img src="//upload-images.jianshu.io/upload_images/3458176-160654766bed3104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp">Paste_Image.png</li>
<li><strong>Maven编译</strong></li>
<li>使用maven编译，唯一需要动的的就是指明编译过程中需要的注解处理程序HibernateAnnotationProcessor。为此需要设置maven-compiler-plugin插件中compiler目标的参数。</li>
<li>  在pom.xml中设置如下：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">   &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">          &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;default-compile&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">              &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">             &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">             &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">              &lt;annotationProcessors&gt;</span><br><span class="line">                &lt;annotationProcessor&gt;com.zlcook.processor.HibernateAnnotationProcessor&lt;/annotationProcessor&gt;</span><br><span class="line">             &lt;/annotationProcessors&gt; </span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">          &lt;/execution&gt;</span><br><span class="line">        &lt;/executions&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">   &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>  执行maven命令</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean compile</span><br></pre></td></tr></table></figure>
  执行完成后在项目根目录下就出现了Person.hbm.xml文件。<ul>
<li>  Person.hbm.xml内容如下：</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping</span><br><span class="line"> PUBLIC &quot;-// Hibernate/Hibernate Ma  pping DTD 3.0//EN&quot;</span><br><span class="line"> &quot;http:// hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line"> &lt;class name=&quot;com.zlcook.annotation.bean.Person&quot; table=&quot;person_inf&quot;&gt;</span><br><span class="line"> &lt;id name=&quot;id&quot; column=&quot;person_id&quot; type=&quot;integer&quot;&gt;</span><br><span class="line"> &lt;generator/&gt;</span><br><span class="line"> &lt;/id&gt;</span><br><span class="line"> &lt;property name=&quot;name&quot; column=&quot;person_name&quot;type=&quot;string&quot;/&gt;</span><br><span class="line"> &lt;property name=&quot;age&quot; column=&quot;person_age&quot;type=&quot;integer&quot;/&gt;</span><br><span class="line"> &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div><div class="article"><hr><h2>版权声明</h2>| 文章作者：<a target="_blank" rel="noopener" href="http://wwwuxt.cc">wwwuxt</a><br>| 文章链接：<a href="http://example.com/2019/03/24/javaannotation%E6%B3%A8%E8%A7%A3-%E5%8E%9F%E7%90%86%E5%88%B0%E6%A1%88%E4%BE%8B/">http://example.com/2019/03/24/javaannotation%E6%B3%A8%E8%A7%A3-%E5%8E%9F%E7%90%86%E5%88%B0%E6%A1%88%E4%BE%8B/</a><br>| 许可协议：<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a><hr></div></main><footer><div class="paginator"><a class="prev" href="/2019/04/01/hadoop%E8%81%94%E9%82%A6/"><!--!= __('< PREV_POST')-->< HADOOP联邦</a><a class="next" href="/2019/03/21/kylin%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><!--!= __('NEXT_POST >')-->KYLIN使用异常处理 ></a></div><div class="clearfix"></div><div class="copyright"><p id="host_by"> <a href="/atom.xml"><i class="fa fa-rss"></i></a><span id="busuanzi_container_site_pv">&nbsp;<i class="fa fa-eye">&nbsp;</i><span id="busuanzi_value_site_pv"><i class="fa fa-spinner"></i></span> times, </span><span id="busanzi_container_site_uv">&nbsp;<i class="fa fa-user">&nbsp;</i><span id="busuanzi_value_site_uv"><i class="fa fa-spinner"></i></span> times.</span><br> &copy; 2017 - 2021 <a target="_blank" rel="noopener" href="http://wwwuxt.cc">wwwuxt</a>. 
 Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/wwwuxt/hexo-theme-artemisX" target="_blank">ArtemisX</a>.<br></p><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-108353521-1']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
console.log('Google Analytics')
</script><script>(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else{
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
    console.log('wwwuxt.cc')
})();
</script><script>(function(){
    var req = GetXmlHttpObject()  
    if (req == null) {  
        console.log("not support AJAX!");  
        return;  
    }
    req.onreadystatechange = function() {  
        if (req.readyState === 4 && req.status === 200) {  
            var deploy_server = req.getResponseHeader("Server");
            console.log(deploy_server)
            if(deploy_server === 'Coding Pages'){
                document.getElementById('host_by').innerHTML+='Hosted by <a target="_blank" rel="noopener" href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>.'
            }
            else if(deploy_server === 'GitHub.com'){
                document.getElementById('host_by').innerHTML+='Hosted by <a target="_blank" rel="noopener" href="https://pages.github.com" style="font-weight: bold">GitHub Pages</a>.'
            }
            else{
                document.getElementById('host_by').innerHTML+='Hosted by <a href="#" style="font-weight: bold">'+ deploy_server + '</a>.'
            }
        }  
    };  
    req.open('GET', document.location, true);
    req.send(null);
})();
function GetXmlHttpObject() {  
    var xmlHttp = null;  
    try {  
        // Firefox, Opera 8.0+, Safari  
        xmlHttp = new XMLHttpRequest();  
    } catch (e) {  
        // Internet Explorer  
        try {  
            xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");  
        } catch (e) {  
            xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");  
        }  
    }  
    return xmlHttp;  
}  </script></body></html>