<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>编程基础篇 | Hexo</title><meta name="description" content="编程基础篇 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/css/font-awesome.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hexo"><img class="logo-image" src="/favicon.ico" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/" target="_self">首页</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/archives" target="_self">归档</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/tags" target="_self">标签</a></li><li class="nav-list-item"><!--a.nav-list-link(class={active: act} href=url_for(value), target=tar)--><a class="nav-list-link" href="/about" target="_self">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">编程基础篇</h1><p class="post-info"><i class="fa fa-calendar">&nbsp;</i>2019-04-22&nbsp;| <i class="fa fa-tags">&nbsp;</i><a class="post-tag-link" href="/tags/%E7%BC%96%E7%A8%8B/">编程&nbsp;·&nbsp;</a><a class="post-tag-link" href="/tags/%E5%9F%BA%E7%A1%80/">基础&nbsp;·&nbsp;</a>&nbsp;| <i class="fa fa-folder-o">&nbsp;</i><a class="post-category-link" href="/categories/program/">program&nbsp;/&nbsp;</a><a class="post-category-link" href="/categories/program/%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80/">其他语言&nbsp;/&nbsp;</a></p><div class="post-content"><h1 id="1-面向对象-oop"><a href="#1-面向对象-oop" class="headerlink" title="1.面向对象 oop"></a>1.面向对象 oop</h1><hr>
<h2 id="一-什么是面向对象"><a href="#一-什么是面向对象" class="headerlink" title="一. 什么是面向对象"></a>一. 什么是面向对象</h2><h3 id="面向过程-与-面向对象"><a href="#面向过程-与-面向对象" class="headerlink" title="面向过程 与 面向对象"></a>面向过程 与 面向对象</h3><p>面向对象：将问题拆解为一个个步骤，依次实现调用 面向过程: 将问题步骤（属性，行为）抽象形成对象，通过不同对象之间的调用，组合解决问题</p>
<h3 id="面向对象的三大特征-和-五大基本原则"><a href="#面向对象的三大特征-和-五大基本原则" class="headerlink" title="面向对象的三大特征 和 五大基本原则"></a>面向对象的三大特征 和 五大基本原则</h3><p><strong>三大特征 封装 继承 多态</strong></p>
<ul>
<li>  封装 隐藏了不可信信息，提供不同级别的数据保护</li>
<li>  继承 对基类扩展， 实现继承 和 接口继承（必须在子类实现）</li>
<li>  多态 相同方法在不同情形下的不同表现 如 以父类对象做参数，传入子类</li>
</ul>
<p><strong>五大基本原则</strong></p>
<ul>
<li>  单一性原则: 低耦合 高内聚</li>
<li>  开放封闭原则：对扩展开放，对修改封闭</li>
<li>  Liskov替换原则：子类必须能够替换基类，保证扩展性，减少代码冗余</li>
<li>  依赖倒置原则：依赖于抽象，基于接口编程</li>
<li>  接口隔离原则：多个专门的小接口，不使用胖接口</li>
</ul>
<h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><p><strong>java如何实现平台无关性</strong></p>
<p>一次编译，多处运行 .class文件字节码 JVM的多平台，jvm只关心 class字节码</p>
<p><strong>jvm 其他支持的语言</strong></p>
<p>scala kotlin groovy scala jruby jython clojure rhino(js 调用java) ceylon（redhat）</p>
<h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><p><strong>为什么说Java中只有值传递</strong></p>
<h3 id="实参-和-形参"><a href="#实参-和-形参" class="headerlink" title="实参 和 形参"></a>实参 和 形参</h3><p>实参：调用有参数方法的时候真正传递的内容 形参：用于解说实参内用的参数</p>
<h3 id="值传递-和-引用传递"><a href="#值传递-和-引用传递" class="headerlink" title="值传递 和 引用传递"></a>值传递 和 引用传递</h3><p>值传递： 调用函数时将实际参数复制一份， 参数修改不会影响实际参数 引用传递： 调用函数是将实际参数的地址传递到函数中，参数修改影响到实际参数</p>
<p>值传递</p>
<p>引用传递</p>
<p>根本区别</p>
<p>会创建副本</p>
<p>不创建副本，引用地址</p>
<p>现象</p>
<p>函数中无法改变原始对象</p>
<p>函数中可以改变原始对象</p>
<p>java中实际传递的都是值，只不过对于对象参数，值的内容是对象的引用</p>
<p>无论是值传递还是引用传递都是一种求值策略，严格意义上是共享传递，即调用参数是传递给函数的实参的地址的拷贝。当位于栈中，（常量等）拷贝该值；当位于堆中，先拿到堆中的地址，再做相关操作。</p>
<h2 id="二-封装-继承-多态"><a href="#二-封装-继承-多态" class="headerlink" title="二. 封装 继承 多态"></a>二. 封装 继承 多态</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一操作作用于不同的对象,可以有不同的解,产生不同的执行结果</p>
<p>=&gt; 多态是一种运行期的状态,又名动态绑定,需要满足的条件</p>
<ul>
<li>  类继承或接口实现</li>
<li>  子类重写父类的方法</li>
<li>  父类引用指向子类的对象</li>
</ul>
<h3 id="方法重写与重载"><a href="#方法重写与重载" class="headerlink" title="方法重写与重载"></a>方法重写与重载</h3><p>重载(Overloading) 和 重写(Overriding)</p>
<p>重载: 函数或方法具有相同的名称,单参数的集合不同,同名不同参 重写: 在子类与父类之间 同名且参数集合相同,子类的新方法将覆盖父类原有的方法</p>
<p><strong>重载 VS 重写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 重载是编译期的概念, 重写是运行期间的概念</span><br><span class="line">2. 重载在编译期已经确定, 是一种编译时多态,即静态多态</span><br></pre></td></tr></table></figure>

<p><strong>重载的条件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 被重载的方法必须改变参数集合</span><br><span class="line">2. 被重载的方法可以改变返回类型(返回类型无关)</span><br><span class="line">3. 被重载的方法可以改变访问修饰符(与可见性无关)</span><br><span class="line">4. 被重载的方法可以声明新的或更广的检查异常</span><br><span class="line">5. 方法在同一个类(同类重载) 或子类(子类重载继承自父类的方法)</span><br></pre></td></tr></table></figure>

<h2 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h2><p><strong>继承</strong>、<strong>组合</strong>和<strong>代理</strong> 是面向对象编程中的 <strong>复用技术</strong></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是类与类之间的层次模型 父类（父接口）与 子类（子接口） 继承是一种 <strong>is-a</strong> 关系</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合是正义与部分拥有的关系, 即 <strong>has-a</strong>的关系</p>
<h3 id="继承与组合的区别与类型"><a href="#继承与组合的区别与类型" class="headerlink" title="继承与组合的区别与类型"></a>继承与组合的区别与类型</h3><p>继承中, 父类细节 对 子类可见 =&gt; 白盒式代码复用 =&gt; 父类变化,派生类随之变化 组合中, 拼装享有对象产生新的、更负载的功能,内部细节不可见 =&gt; 黑盒式代码复用</p>
<p>继承,编译期确定具体的继承关系 组合,面向接口编程,在运行期确定具体的组合关系</p>
<h4 id="组合和继承优缺点对比"><a href="#组合和继承优缺点对比" class="headerlink" title="组合和继承优缺点对比"></a>组合和继承优缺点对比</h4><p>组合关系</p>
<p>继承关系</p>
<p>不破坏封装,松耦合</p>
<p>破坏封装,子类与父类耦合紧密</p>
<p>良好的可扩展性</p>
<p>支持扩展,复杂度提升</p>
<p>支持动态组合,运行时整体对象可以选择不同的局部对象</p>
<p>不支持动态组合</p>
<p>整体类可以包装局部类形成新的接口</p>
<p>子类不能改变父类的接口</p>
<p>整体类无法获取局部类接口</p>
<p>子类能自动继承父类的接口</p>
<p>创建整体时,需要创建所有局部对象</p>
<p>创建子类对象无需创建父类对象</p>
<p><strong>确定需要使用子类向父类的向上转型选用继承,优先使用接口编程的组合关系,更安全简单灵活高效</strong></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数 特殊的方法 用于创建对象是初始化对象,为对象的成员变量赋初始值 一个类可以有多个构造方法,重载 构造器没有返回类型,不会被继承,承担初始化成员对象数据的任务 在没有专门编写,生成默认的构造函数, 成员变量会进行默认初始化,默认值 int -&gt; 0 Integer -&gt; null</p>
<h3 id="类变量-成员变量-和-局部变量"><a href="#类变量-成员变量-和-局部变量" class="headerlink" title="类变量 成员变量 和 局部变量"></a>类变量 成员变量 和 局部变量</h3><p>类变量: 位于 JVM 方法区 成员变量: 位于 JVM 堆内存 局部变量: 位于 JVM 栈内存</p>
<h3 id="成员变量和方法的作用域"><a href="#成员变量和方法的作用域" class="headerlink" title="成员变量和方法的作用域"></a>成员变量和方法的作用域</h3><p>修饰词</p>
<p>可见范围</p>
<p>public</p>
<p>所有类或对象可见,可访问</p>
<p>private</p>
<p>私有方法变量,只有当前类可访问</p>
<p>protected</p>
<p>受保护的,当前类及相同package目录下的<strong>其他类可见,子类可见</strong></p>
<p>default</p>
<p>只有当前类和同一package目录下的其他类可见**,子类也不可见**</p>
</div></article></div><div class="article"><hr><h2>版权声明</h2>| 文章作者：<a target="_blank" rel="noopener" href="http://wwwuxt.cc">wwwuxt</a><br>| 文章链接：<a href="http://example.com/2019/04/22/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/">http://example.com/2019/04/22/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</a><br>| 许可协议：<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a><hr></div></main><footer><div class="paginator"><a class="prev" href="/2019/04/23/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><!--!= __('< PREV_POST')-->< JAVA基础知识</a><a class="next" href="/2019/04/22/java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"><!--!= __('NEXT_POST >')-->JAVA常见问题集合 ></a></div><div class="clearfix"></div><div class="copyright"><p id="host_by"> <a href="/atom.xml"><i class="fa fa-rss"></i></a><span id="busuanzi_container_site_pv">&nbsp;<i class="fa fa-eye">&nbsp;</i><span id="busuanzi_value_site_pv"><i class="fa fa-spinner"></i></span> times, </span><span id="busanzi_container_site_uv">&nbsp;<i class="fa fa-user">&nbsp;</i><span id="busuanzi_value_site_uv"><i class="fa fa-spinner"></i></span> times.</span><br> &copy; 2017 - 2021 <a target="_blank" rel="noopener" href="http://wwwuxt.cc">wwwuxt</a>. 
 Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/wwwuxt/hexo-theme-artemisX" target="_blank">ArtemisX</a>.<br></p><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-108353521-1']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
console.log('Google Analytics')
</script><script>(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else{
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
    console.log('wwwuxt.cc')
})();
</script><script>(function(){
    var req = GetXmlHttpObject()  
    if (req == null) {  
        console.log("not support AJAX!");  
        return;  
    }
    req.onreadystatechange = function() {  
        if (req.readyState === 4 && req.status === 200) {  
            var deploy_server = req.getResponseHeader("Server");
            console.log(deploy_server)
            if(deploy_server === 'Coding Pages'){
                document.getElementById('host_by').innerHTML+='Hosted by <a target="_blank" rel="noopener" href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>.'
            }
            else if(deploy_server === 'GitHub.com'){
                document.getElementById('host_by').innerHTML+='Hosted by <a target="_blank" rel="noopener" href="https://pages.github.com" style="font-weight: bold">GitHub Pages</a>.'
            }
            else{
                document.getElementById('host_by').innerHTML+='Hosted by <a href="#" style="font-weight: bold">'+ deploy_server + '</a>.'
            }
        }  
    };  
    req.open('GET', document.location, true);
    req.send(null);
})();
function GetXmlHttpObject() {  
    var xmlHttp = null;  
    try {  
        // Firefox, Opera 8.0+, Safari  
        xmlHttp = new XMLHttpRequest();  
    } catch (e) {  
        // Internet Explorer  
        try {  
            xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");  
        } catch (e) {  
            xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");  
        }  
    }  
    return xmlHttp;  
}  </script></body></html>